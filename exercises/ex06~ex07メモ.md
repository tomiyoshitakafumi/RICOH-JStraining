もう1つのオブジェクトをプロトタイプと呼び、オブジェクトはこのプロトタイプのプロパティを継承する。
プロトタイプはobject見たいな関連漬けされているもの。そのプロパティを継承している(xとかprototypeとか)
プロトタイプとprototypeプロパティは違う
プロトタイプオブジェクトはObject.prototypeとして参照できる。
prototypeプロパティを持つオブジェクトは少ない
連想配列 object["property"]
独自プロパティその場の継承されてない物
let o = Object.create({x: 1});のo.xは継承であって独自プロパティではない

存在しないオブジェクトに対して.xとするとエラー
なのでa?.xを使う時はaがnullになるときだけ
シリアライズは直列化 オブジェクトを、再度同じオブジェクトに戻せるような文字列に変換すること
jsonにとか
JSON.stringify()は、オブジェクトの列挙可な独自プロパティだけをシリアライズ

let = { toString:function() { return "a"; } };
or
let = {toString() { return "a"; }}

Symbol() に引数とし
て文字列を引数として渡すこともできます。Symbolを文字列に変換したときに、この引数として
渡した文字列が使われます。ただし、これはあくまでデバッグ用です。

重要
> 配列のインデックスとオブジェクトのプロパティ名をはっきりと区別しておいてください。すべ
> てのインデックスはプロパティ名になります。しかし、0から2
> 32−2までの整数のプロパティ名の
> みがインデックスです。すべての配列はオブジェクトですので、配列に対して任意の名前のプロパ
> ティを作成できます。ただし、インデックスを使う場合は、配列は特殊な振る舞いをして、必要に
> 応じてlengthプロパティを更新してくれます。
> 負数や整数ではない数値を使って配列をインデックスすることもできます。このようなインデッ
> クスを使うと、数値は文字列に変換され、この文字列がプロパティ名として使われます。この場
> 合、プロパティ名は非負数の整数ではないので、配列のインデックスとしてではなく、通常のオブ
> ジェクトプロパティとして処理されます。また、反対に、意図せず非負数の整数となる文字列を
> 使って配列をインデックスした場合、オブジェクトのプロパティとしてではなく、配列のインデッ
> クスとして処理されます。

# 7章
反復可能とは　for of 文字列は反復可能
JavaScript は、配列の数値インデックスを文字列に変換します

p148
プロトタイプオブジェクトからプロパティ
を継承します
↑このプロパティとは何？Object.prototypeではない？
ほとんどのオブジェクトはプロトタイプを持ちますが、ほとんどのオブジェクトは prototype という名前のプロパティを持
ちません。
これは{ prototype:value}とならんのか？


p175
疎な配列は、密な配列よりも実行速度が遅い代わりに、メモリ効率はよくなります。また、疎な
配列では、要素を探すのに、通常のオブジェクトプロパティを探すのと同じくらい時間がかかり
ます。
これは普通の密の配列は早いのか？

p175

let a1 = [,]; // この配列は要素を持たず、lengthは1になる。
let a2 = [undefined]; // この配列はundefined値の要素を1つ持つ。
これは別なのか

p179 undefinedが入るならforEach使えばよさそ

# 講義ない

Q
{a:2}と{"a":2}の違いは?
→同じ1つのaになる
p145
また、オブジェクトに対して、ライブラリ関数中で悪意がなくとも意図しない変更をされてしま
わないようにするときにも、Object.create()が使えます。オブジェクトを直接関数に渡すので
はなく、オブジェクトを継承したオブジェクトを渡すようにすれば変更されずにすみます。関数の
中でオブジェクトのプロパティを読み出した場合は、継承した値が読み出されます。一方で、プロ
パティに値を設定しても、元のオブジェクトは変更されません。例を見てください。

a= {b:3};

c= Object.create(a);
c.b=4
a.bは3のまま

移譲は移譲してからｺﾞﾆｮｺﾞﾆｮできる。
継承は継承した値を変えることはできない
値も権限も継承されない
![img_1.png](img_1.png)

ディスクリプタ
* 書き込み可（writable）属性は、プロパティに値を設定できるかどうかを指定します。
  ● 列挙可（enumerable）属性は、for/inループでプロパティ名を調べられるようにするかど
  うかを指定します。
  ● 再定義可（configurable）属性は、プロパティを削除できるかどうか、属性を変更できるか
  どうかを指定します。

Q.
symbolでプロトタイプ
for (let c in b)
継承プロパティの中でシンボルのプロパティ名を取得する方法はありますか？
できそう
Q.ディープコピーはプロトタイプどうなるの？
→しません
オブジェクトの関数はp.rだけど宣言
const random = {
get octet() { return Math.floor(Math.random()*256); },
get uint16() { return Math.floor(Math.random()*65536); },
get int16() { return Math.floor(Math.random()*65536)-32768; }
};
getterなのでrandom.octetとアクセスする。 random.octet()ではない

Q
線形オーダーn
対数オーダーn^2
ハッシュテーブルを見る
一様性

Q new Array()と Array()は違う? コンストラクタ
ファクトリーパターン?

説明できるようにコメント書く

6.8
Q //ので今回はn^2になっているのでちょっと重い hasownpropaty はハッシュになっているのでn
、hasOwnProperty()とpropertyIsEnumerable()は何？

配列の計算量とかあまり考えなくてもいい。あまり公開されてない。なぜかと言うと内部で変わっているから
(一度決めると替えられない)
配列ライクだと配列だと過剰だけど機能を削る事ができる

[[],[]]と number[][]

実装を間違えるテストを書く　バグを検出するためのテスト

Q.

```javascript
/**
 * fizzbuzzの文字列をコンソール出力します。
 * @param {number} n 自然数
 */
function fizzbuzz(n) {
  const nArry = new Array(n).fill(0).map((_, index) => {
    return index + 1;
  });
  const fizzArry = nArry.filter((value) => value % 3 === 0);
  const buzzArry = nArry.filter((value) => value % 5 === 0);
  const fizzbuzzArry = nArry.filter((value) => value % 15 === 0);
  buzzArry.forEach((value) => {
    nArry[value -1] = "Buzz"
  });
  fizzArry.forEach((value) => {
    nArry[value -1] = "Fizz";
  });
  fizzbuzzArry.forEach((value) => {
    // valueから1引いた値がindex
    nArry[value -1] = "FizzBuzz";
  });
  nArry.forEach((value) => {
    console.log(value);
  })
}
 
```

    // sliceは破壊的変更じゃないらしい

Q.ディスクリプタ
Q.イテレーターメソッド定義
値を一つつづ取り出す関数
ディープコピーはプロトタイプはコピーされないのか

● グローバル定数：undefined、Infinity、NaN
● グローバル関数：isNaN()、parseInt()（§3.9.2参照）、eval()（§4.12参照）
● コンストラクタ関数：Date()、RegExp()、String()、Object()、Array()（§3.9.2参照）
● グローバルオブジェクト：MathとJSON（§6.8参照）
