もう1つのオブジェクトをプロトタイプと呼び、オブジェクトはこのプロトタイプのプロパティを継承する。
プロトタイプはobject見たいな関連漬けされているもの。そのプロパティを継承している(xとかprototypeとか)
プロトタイプとprototypeプロパティは違う
プロトタイプオブジェクトはObject.prototypeとして参照できる。
prototypeプロパティを持つオブジェクトは少ない
連想配列 object["property"]
独自プロパティその場の継承されてない物
let o = Object.create({x: 1});のo.xは継承であって独自プロパティではない

存在しないオブジェクトに対して.xとするとエラー
なのでa?.xを使う時はaがnullになるときだけ
シリアライズは直列化 オブジェクトを、再度同じオブジェクトに戻せるような文字列に変換すること
jsonにとか
JSON.stringify()は、オブジェクトの列挙可な独自プロパティだけをシリアライズ

let = { toString:function() { return "a"; } };
or
let = {toString() { return "a"; }}

Symbol() に引数とし
て文字列を引数として渡すこともできます。Symbolを文字列に変換したときに、この引数として
渡した文字列が使われます。ただし、これはあくまでデバッグ用です。

重要
> 配列のインデックスとオブジェクトのプロパティ名をはっきりと区別しておいてください。すべ
てのインデックスはプロパティ名になります。しかし、0から2
32−2までの整数のプロパティ名の
みがインデックスです。すべての配列はオブジェクトですので、配列に対して任意の名前のプロパ
ティを作成できます。ただし、インデックスを使う場合は、配列は特殊な振る舞いをして、必要に
応じてlengthプロパティを更新してくれます。
負数や整数ではない数値を使って配列をインデックスすることもできます。このようなインデッ
クスを使うと、数値は文字列に変換され、この文字列がプロパティ名として使われます。この場
合、プロパティ名は非負数の整数ではないので、配列のインデックスとしてではなく、通常のオブ
ジェクトプロパティとして処理されます。また、反対に、意図せず非負数の整数となる文字列を
使って配列をインデックスした場合、オブジェクトのプロパティとしてではなく、配列のインデッ
クスとして処理されます。

# 7章
反復可能とは　for of 文字列は反復可能
JavaScript は、配列の数値インデックスを文字列に変換します

p148
プロトタイプオブジェクトからプロパティ
を継承します
↑このプロパティとは何？Object.prototypeではない？
ほとんどのオブジェクトはプロトタイプを持ちますが、ほとんどのオブジェクトは prototype という名前のプロパティを持
ちません。
これは{ prototype:value}とならんのか？


p175
疎な配列は、密な配列よりも実行速度が遅い代わりに、メモリ効率はよくなります。また、疎な
配列では、要素を探すのに、通常のオブジェクトプロパティを探すのと同じくらい時間がかかり
ます。
これは普通の密の配列は早いのか？

p175

let a1 = [,]; // この配列は要素を持たず、lengthは1になる。
let a2 = [undefined]; // この配列はundefined値の要素を1つ持つ。
これは別なのか

p179 undefinedが入るならforEach使えばよさそう