nullはリテラル(定数値　プログラム中に直接埋め込まれた定数値　変数ではなく　let a = "a"の文字みたいなやつ)
オペランドは "a"+2 の+ではないもの
undefinedは変数

基本undefinedを使う方がよい
リテラルは単項式

deleteはundefinedを代入と同じ

全ての数字は浮動小数点
基本形はstringやnumber
valueOf()は継承元の方表す。 ようは オブジェクトそのもの
BingIntは通常の数値ではないので通常の数値に返還される+や++は使えない
a<<1で2倍となる

+ 演算子は、文字列処理を優先します。オペランドのいずれかが文字列の場合、連結処理が行われます。
  比較演算子は数値を優先します。

副作用がある文は式文 関数呼び出しや代入など
式は評価される式[式]文は宣言や副作用
ofでの反復はunicode .lengthはUTF-16
関数呼び出しは式
関数はオブジェクト
code point(符号位置)はunicode code unitはutf -16 で2つだったり\u{n}は
式.識別子
式[式]
、&&演算子が「true に変換される値」や「false に変換される値」を返す true falseではない

# 問題のページ

ex02 バックスペースの文字列はあるのか？ →Unicodeで居れる可能性

# 本のページ

p71の2番目という箇所がわからん

+ プロパティを計算結果で決める時はあるのか？

p107文内部の代入や関数呼び出しは副作用？
では副作用ではない式の評価はほぼなくないか？(定数のみ)
let a=1の初期化は副作用？
p119のo.nextはo?.nextでは？
p137 オブジェクトはホイスティングされるのか？またされないものとされるものの種類

# 講義

タダ

0での割り算はNaNとかinfとかでエラーじゃないかも
「a ? b : c ? d : e」は
「(a ? b : c) ? d : e」 ではなく、
「a ? b : (c ? d : e)」 になるということ。
一方で、評価は左からだからa == trueなら:以降は評価されない。
-1はtrue
!(b^0)は!(b)
bit個数計算は 01|10|11|11→0010|0100
(5) ['r', 'i', 'c', empty, 'h']
副作用もあるよ
let a="a"
これは副作用ではない
let a;//undefined
a="a"; これは副作用

```javascript
obj = {a:2}; 
const a = 1;
with(obj) console.log(a);
```

withのスコープ内にaが定義されるため2となる

jestではtoBe(false)以外にも.toFalsy()もあったりするがfalse以外でご検知するかも
javasctipは変わらないがif elseよりswitchが実行速度速い言語もあるのか

javascritpやtypesciptのエラーはJava見たいにあまり力を入れてやらない。なぜならcatchとか型指定定できないから。
javaみたいにキャッチしなければ上に投げるという動作ことができない。でもinstanceofはｄけいる
MDNは昔はwikiみたいに編集ができるが今はPR出す必要があるので信用していいかも
javascriptとかでは挙動が違ったりするのでfalsyは恐いかも
objectの中でちょろっと返す goだと参考演算子 成功するたとかでdo whileとかもありかも でもwhileでif でブレイクするのかも 三項演算子がネストしたら怪しいと思おう